// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

/**
 * @title ILockableCapability
 * @dev Generic interface for representing a locked capability that can be
 *      delegated and eventually consumed ("spent") by a designated spender.
 *
 *      A "capability" here is any predefined state-changing operation: it may
 *      involve tokens, a function call, or any other effect defined by the
 *      implementing contract.
 *
 *      Core guarantees:
 *        - Each lock is identified by a unique lockId, generated by the
 *          implementing contract.
 *        - For each existing lock, there is exactly one current spender
 *          address (the "authorized spender").
 *        - Initially, the lock creator is both the owner and the spender.
 *        - Only the current spender is allowed to spend, cancel, or delegate
 *          the lock.
 *        - This interface does not prescribe expiry, auto-cancellation, or
 *          owner-controlled clawback. Once a lock is created and delegated,
 *          the original owner cannot prevent the current spender from using
 *          it. Such constraints may be implemented by delegating the lock to
 *          a separate policy contract that provides additional constraints
 *          on spending or cancellation.
 *
 *      The intent is that, so long as a lock remains active and the caller is
 *      the current spender, the implementing contract MUST NOT introduce
 *      arbitrary revocation or expiry logic beyond:
 *        - the lock having already been spent or cancelled; or
 *        - the caller not being the current spender; or
 *        - the provided data failing validation as defined by the specific
 *          implementation.
 */
interface ILockableCapability {
    struct LockInfo {
        // The address that originally created the lock
        address owner;
        // The address that is currently authorized to spend/cancel/delegate the lock
        address spender;
    }

    /**
     * @dev Thrown when a lock does not exist or is no longer active.
     */
    error LockNotActive(bytes32 lockId);

    /**
     * @dev Thrown when the caller is not the current spender for the given lock.
     */
    error LockUnauthorized(bytes32 lockId, address caller);

    /**
     * @dev Emitted when a lock is successfully spent.
     */
    event LockSpent(bytes32 indexed lockId, address indexed spender, bytes data);

    /**
     * @dev Emitted when a lock is successfully cancelled.
     */
    event LockCancelled(bytes32 indexed lockId, address indexed spender, bytes data);

    /**
     * @dev Emitted when spending authority is delegated from one address to another.
     */
    event LockDelegated(
        bytes32 indexed lockId,
        address indexed from,
        address indexed to,
        bytes data
    );

    /**
     * @dev Consume ("spend") the capability represented by this lock
     *      (for example, releasing or claiming tokens).
     *
     * Requirements:
     *  - MUST revert with LockUnauthorized(lockId, msg.sender) if msg.sender
     *    is not the current spender for lockId.
     *  - MUST revert with LockNotActive(lockId) if the lock does not exist or
     *    is no longer active (e.g. already spent or cancelled).
     *  - MUST mark the lock as no longer active (terminal state) if it
     *    completes successfully.
     *
     * Implementations MAY use the data parameter to carry additional metadata
     * or authorization required to complete the operation.
     *
     * @param lockId The identifier of the lock.
     * @param data   Arbitrary implementation-specific data. MUST NOT influence
     *               the outcome of the operation, but may be used to carry additional
     *               metadata or authorization required to complete the operation.
     */
    function spendLock(bytes32 lockId, bytes calldata data) external;

    /**
     * @dev Cancel a lock without performing its effect.
     *
     *      Typical implementations will refund or otherwise re-route the
     *      underlying value or effect (often to the owner), but the exact
     *      semantics are implementation-specific and not defined by this
     *      interface.
     *
     * Requirements:
     *  - MUST revert with LockUnauthorized(lockId, msg.sender) if msg.sender
     *    is not the current spender for lockId.
     *  - MUST revert with LockNotActive(lockId) if the lock does not exist or
     *    is no longer active (e.g. already spent or cancelled).
     *  - MUST mark the lock as no longer active (terminal state) if it
     *    completes successfully.
     *
     * @param lockId The identifier of the lock.
     * @param data   Arbitrary implementation-specific data. MUST NOT influence
     *               the outcome of the operation, but may be used to carry additional
     *               metadata or authorization required to complete the operation.
     */
    function cancelLock(bytes32 lockId, bytes calldata data) external;

    /**
     * @dev Delegate spending authority for this lock to a new address.
     *
     *      After delegation, the previous spender MUST no longer be allowed to
     *      spend or cancel the lock (unless they later regain spender status).
     *
     * Requirements:
     *  - MUST revert with LockUnauthorized(lockId, msg.sender) if msg.sender
     *    is not the current spender for lockId.
     *  - MUST revert with LockNotActive(lockId) if the lock does not exist or
     *    is no longer active.
     *
     * @param lockId     The identifier of the lock.
     * @param newSpender The address of the new lock spender.
     * @param data       Arbitrary implementation-specific data.
     */
    function delegateLock(bytes32 lockId, address newSpender, bytes calldata data) external;

    /**
     * @dev Get current information about a lock.
     *
     * Requirements:
     *  - MUST revert with LockNotActive(lockId) if the lock does not exist or
     *    is no longer active.
     *
     * @param lockId The identifier of the lock.
     * @return info  The information about the lock.
     */
    function getLock(
        bytes32 lockId
    ) external view returns (LockInfo memory info);

    // ------------------------------------------------------------------------
    // Non-normative examples
    // ------------------------------------------------------------------------
    //
    // The events and methods below are illustrative only. The core interface does
    // not prescribe how locks are created or updated. Implementations are expected
    // to provide one or more ways to create and manage locks, and may choose
    // to use a deterministic lockId derivation pattern as shown below.
    //
    // struct LockParams { ... }
    // struct UpdateLockParams { ... }
    //
    // event LockCreated(
    //     bytes32 indexed lockId,
    //     address indexed owner,
    //     address indexed spender,
    //     ...
    // );
    //
    // event LockUpdated(
    //     bytes32 indexed lockId,
    //     address indexed operator,
    //     ...
    // );
    //
    // function createLock(
    //     LockParams calldata params,
    //     bytes32 salt,
    //     bytes calldata data
    // ) external returns (bytes32 lockId);
    //
    // function updateLock(
    //     bytes32 lockId,
    //     UpdateLockParams calldata params,
    //     bytes calldata data
    // ) external;
    //
    // function computeLockId(LockParams calldata params, bytes32 salt)
    //     public
    //     view
    //     returns (bytes32 lockId)
    // {
    //     return keccak256(abi.encode(address(this), msg.sender, params, salt));
    // }
}
