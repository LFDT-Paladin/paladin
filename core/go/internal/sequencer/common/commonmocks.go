// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package common

import (
	"context"
	"time"

	"github.com/LFDT-Paladin/paladin/core/internal/components"
	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockClock creates a new instance of MockClock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClock(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClock {
	mock := &MockClock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockClock is an autogenerated mock type for the Clock type
type MockClock struct {
	mock.Mock
}

type MockClock_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClock) EXPECT() *MockClock_Expecter {
	return &MockClock_Expecter{mock: &_m.Mock}
}

// Duration provides a mock function for the type MockClock
func (_mock *MockClock) Duration(milliseconds int) Duration {
	ret := _mock.Called(milliseconds)

	if len(ret) == 0 {
		panic("no return value specified for Duration")
	}

	var r0 Duration
	if returnFunc, ok := ret.Get(0).(func(int) Duration); ok {
		r0 = returnFunc(milliseconds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Duration)
		}
	}
	return r0
}

// MockClock_Duration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Duration'
type MockClock_Duration_Call struct {
	*mock.Call
}

// Duration is a helper method to define mock.On call
//   - milliseconds int
func (_e *MockClock_Expecter) Duration(milliseconds interface{}) *MockClock_Duration_Call {
	return &MockClock_Duration_Call{Call: _e.mock.On("Duration", milliseconds)}
}

func (_c *MockClock_Duration_Call) Run(run func(milliseconds int)) *MockClock_Duration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 int
		if args[0] != nil {
			arg0 = args[0].(int)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockClock_Duration_Call) Return(duration Duration) *MockClock_Duration_Call {
	_c.Call.Return(duration)
	return _c
}

func (_c *MockClock_Duration_Call) RunAndReturn(run func(milliseconds int) Duration) *MockClock_Duration_Call {
	_c.Call.Return(run)
	return _c
}

// HasExpired provides a mock function for the type MockClock
func (_mock *MockClock) HasExpired(time Time, duration Duration) bool {
	ret := _mock.Called(time, duration)

	if len(ret) == 0 {
		panic("no return value specified for HasExpired")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func(Time, Duration) bool); ok {
		r0 = returnFunc(time, duration)
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockClock_HasExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasExpired'
type MockClock_HasExpired_Call struct {
	*mock.Call
}

// HasExpired is a helper method to define mock.On call
//   - time Time
//   - duration Duration
func (_e *MockClock_Expecter) HasExpired(time interface{}, duration interface{}) *MockClock_HasExpired_Call {
	return &MockClock_HasExpired_Call{Call: _e.mock.On("HasExpired", time, duration)}
}

func (_c *MockClock_HasExpired_Call) Run(run func(time Time, duration Duration)) *MockClock_HasExpired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 Time
		if args[0] != nil {
			arg0 = args[0].(Time)
		}
		var arg1 Duration
		if args[1] != nil {
			arg1 = args[1].(Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockClock_HasExpired_Call) Return(b bool) *MockClock_HasExpired_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockClock_HasExpired_Call) RunAndReturn(run func(time Time, duration Duration) bool) *MockClock_HasExpired_Call {
	_c.Call.Return(run)
	return _c
}

// Now provides a mock function for the type MockClock
func (_mock *MockClock) Now() Time {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Now")
	}

	var r0 Time
	if returnFunc, ok := ret.Get(0).(func() Time); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Time)
		}
	}
	return r0
}

// MockClock_Now_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Now'
type MockClock_Now_Call struct {
	*mock.Call
}

// Now is a helper method to define mock.On call
func (_e *MockClock_Expecter) Now() *MockClock_Now_Call {
	return &MockClock_Now_Call{Call: _e.mock.On("Now")}
}

func (_c *MockClock_Now_Call) Run(run func()) *MockClock_Now_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClock_Now_Call) Return(time Time) *MockClock_Now_Call {
	_c.Call.Return(time)
	return _c
}

func (_c *MockClock_Now_Call) RunAndReturn(run func() Time) *MockClock_Now_Call {
	_c.Call.Return(run)
	return _c
}

// ScheduleInterval provides a mock function for the type MockClock
func (_mock *MockClock) ScheduleInterval(context1 context.Context, duration Duration, fn func()) func() {
	ret := _mock.Called(context1, duration, fn)

	if len(ret) == 0 {
		panic("no return value specified for ScheduleInterval")
	}

	var r0 func()
	if returnFunc, ok := ret.Get(0).(func(context.Context, Duration, func()) func()); ok {
		r0 = returnFunc(context1, duration, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(func())
		}
	}
	return r0
}

// MockClock_ScheduleInterval_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScheduleInterval'
type MockClock_ScheduleInterval_Call struct {
	*mock.Call
}

// ScheduleInterval is a helper method to define mock.On call
//   - context1 context.Context
//   - duration Duration
//   - fn func()
func (_e *MockClock_Expecter) ScheduleInterval(context1 interface{}, duration interface{}, fn interface{}) *MockClock_ScheduleInterval_Call {
	return &MockClock_ScheduleInterval_Call{Call: _e.mock.On("ScheduleInterval", context1, duration, fn)}
}

func (_c *MockClock_ScheduleInterval_Call) Run(run func(context1 context.Context, duration Duration, fn func())) *MockClock_ScheduleInterval_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 Duration
		if args[1] != nil {
			arg1 = args[1].(Duration)
		}
		var arg2 func()
		if args[2] != nil {
			arg2 = args[2].(func())
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockClock_ScheduleInterval_Call) Return(cancel func()) *MockClock_ScheduleInterval_Call {
	_c.Call.Return(cancel)
	return _c
}

func (_c *MockClock_ScheduleInterval_Call) RunAndReturn(run func(context1 context.Context, duration Duration, fn func()) func()) *MockClock_ScheduleInterval_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDuration creates a new instance of MockDuration. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDuration(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDuration {
	mock := &MockDuration{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockDuration is an autogenerated mock type for the Duration type
type MockDuration struct {
	mock.Mock
}

type MockDuration_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDuration) EXPECT() *MockDuration_Expecter {
	return &MockDuration_Expecter{mock: &_m.Mock}
}

// NewMockTime creates a new instance of MockTime. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTime(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTime {
	mock := &MockTime{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTime is an autogenerated mock type for the Time type
type MockTime struct {
	mock.Mock
}

type MockTime_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTime) EXPECT() *MockTime_Expecter {
	return &MockTime_Expecter{mock: &_m.Mock}
}

// NewMockHooks creates a new instance of MockHooks. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockHooks(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockHooks {
	mock := &MockHooks{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockHooks is an autogenerated mock type for the Hooks type
type MockHooks struct {
	mock.Mock
}

type MockHooks_Expecter struct {
	mock *mock.Mock
}

func (_m *MockHooks) EXPECT() *MockHooks_Expecter {
	return &MockHooks_Expecter{mock: &_m.Mock}
}

// GetBlockHeight provides a mock function for the type MockHooks
func (_mock *MockHooks) GetBlockHeight() int64 {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetBlockHeight")
	}

	var r0 int64
	if returnFunc, ok := ret.Get(0).(func() int64); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(int64)
	}
	return r0
}

// MockHooks_GetBlockHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockHeight'
type MockHooks_GetBlockHeight_Call struct {
	*mock.Call
}

// GetBlockHeight is a helper method to define mock.On call
func (_e *MockHooks_Expecter) GetBlockHeight() *MockHooks_GetBlockHeight_Call {
	return &MockHooks_GetBlockHeight_Call{Call: _e.mock.On("GetBlockHeight")}
}

func (_c *MockHooks_GetBlockHeight_Call) Run(run func()) *MockHooks_GetBlockHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockHooks_GetBlockHeight_Call) Return(n int64) *MockHooks_GetBlockHeight_Call {
	_c.Call.Return(n)
	return _c
}

func (_c *MockHooks_GetBlockHeight_Call) RunAndReturn(run func() int64) *MockHooks_GetBlockHeight_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeName provides a mock function for the type MockHooks
func (_mock *MockHooks) GetNodeName() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetNodeName")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockHooks_GetNodeName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeName'
type MockHooks_GetNodeName_Call struct {
	*mock.Call
}

// GetNodeName is a helper method to define mock.On call
func (_e *MockHooks_Expecter) GetNodeName() *MockHooks_GetNodeName_Call {
	return &MockHooks_GetNodeName_Call{Call: _e.mock.On("GetNodeName")}
}

func (_c *MockHooks_GetNodeName_Call) Run(run func()) *MockHooks_GetNodeName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockHooks_GetNodeName_Call) Return(s string) *MockHooks_GetNodeName_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockHooks_GetNodeName_Call) RunAndReturn(run func() string) *MockHooks_GetNodeName_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEngineIntegration creates a new instance of MockEngineIntegration. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEngineIntegration(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEngineIntegration {
	mock := &MockEngineIntegration{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEngineIntegration is an autogenerated mock type for the EngineIntegration type
type MockEngineIntegration struct {
	mock.Mock
}

type MockEngineIntegration_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEngineIntegration) EXPECT() *MockEngineIntegration_Expecter {
	return &MockEngineIntegration_Expecter{mock: &_m.Mock}
}

// AssembleAndSign provides a mock function for the type MockEngineIntegration
func (_mock *MockEngineIntegration) AssembleAndSign(ctx context.Context, transactionID uuid.UUID, preAssembly *components.TransactionPreAssembly, stateLocksJSON []byte, blockHeight int64) (*components.TransactionPostAssembly, error) {
	ret := _mock.Called(ctx, transactionID, preAssembly, stateLocksJSON, blockHeight)

	if len(ret) == 0 {
		panic("no return value specified for AssembleAndSign")
	}

	var r0 *components.TransactionPostAssembly
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, *components.TransactionPreAssembly, []byte, int64) (*components.TransactionPostAssembly, error)); ok {
		return returnFunc(ctx, transactionID, preAssembly, stateLocksJSON, blockHeight)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, *components.TransactionPreAssembly, []byte, int64) *components.TransactionPostAssembly); ok {
		r0 = returnFunc(ctx, transactionID, preAssembly, stateLocksJSON, blockHeight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*components.TransactionPostAssembly)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, *components.TransactionPreAssembly, []byte, int64) error); ok {
		r1 = returnFunc(ctx, transactionID, preAssembly, stateLocksJSON, blockHeight)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEngineIntegration_AssembleAndSign_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssembleAndSign'
type MockEngineIntegration_AssembleAndSign_Call struct {
	*mock.Call
}

// AssembleAndSign is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionID uuid.UUID
//   - preAssembly *components.TransactionPreAssembly
//   - stateLocksJSON []byte
//   - blockHeight int64
func (_e *MockEngineIntegration_Expecter) AssembleAndSign(ctx interface{}, transactionID interface{}, preAssembly interface{}, stateLocksJSON interface{}, blockHeight interface{}) *MockEngineIntegration_AssembleAndSign_Call {
	return &MockEngineIntegration_AssembleAndSign_Call{Call: _e.mock.On("AssembleAndSign", ctx, transactionID, preAssembly, stateLocksJSON, blockHeight)}
}

func (_c *MockEngineIntegration_AssembleAndSign_Call) Run(run func(ctx context.Context, transactionID uuid.UUID, preAssembly *components.TransactionPreAssembly, stateLocksJSON []byte, blockHeight int64)) *MockEngineIntegration_AssembleAndSign_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 *components.TransactionPreAssembly
		if args[2] != nil {
			arg2 = args[2].(*components.TransactionPreAssembly)
		}
		var arg3 []byte
		if args[3] != nil {
			arg3 = args[3].([]byte)
		}
		var arg4 int64
		if args[4] != nil {
			arg4 = args[4].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockEngineIntegration_AssembleAndSign_Call) Return(transactionPostAssembly *components.TransactionPostAssembly, err error) *MockEngineIntegration_AssembleAndSign_Call {
	_c.Call.Return(transactionPostAssembly, err)
	return _c
}

func (_c *MockEngineIntegration_AssembleAndSign_Call) RunAndReturn(run func(ctx context.Context, transactionID uuid.UUID, preAssembly *components.TransactionPreAssembly, stateLocksJSON []byte, blockHeight int64) (*components.TransactionPostAssembly, error)) *MockEngineIntegration_AssembleAndSign_Call {
	_c.Call.Return(run)
	return _c
}

// GetBlockHeight provides a mock function for the type MockEngineIntegration
func (_mock *MockEngineIntegration) GetBlockHeight(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockHeight")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEngineIntegration_GetBlockHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBlockHeight'
type MockEngineIntegration_GetBlockHeight_Call struct {
	*mock.Call
}

// GetBlockHeight is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEngineIntegration_Expecter) GetBlockHeight(ctx interface{}) *MockEngineIntegration_GetBlockHeight_Call {
	return &MockEngineIntegration_GetBlockHeight_Call{Call: _e.mock.On("GetBlockHeight", ctx)}
}

func (_c *MockEngineIntegration_GetBlockHeight_Call) Run(run func(ctx context.Context)) *MockEngineIntegration_GetBlockHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEngineIntegration_GetBlockHeight_Call) Return(n int64, err error) *MockEngineIntegration_GetBlockHeight_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockEngineIntegration_GetBlockHeight_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *MockEngineIntegration_GetBlockHeight_Call {
	_c.Call.Return(run)
	return _c
}

// GetStateLocks provides a mock function for the type MockEngineIntegration
func (_mock *MockEngineIntegration) GetStateLocks(ctx context.Context) ([]byte, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetStateLocks")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]byte, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []byte); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEngineIntegration_GetStateLocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStateLocks'
type MockEngineIntegration_GetStateLocks_Call struct {
	*mock.Call
}

// GetStateLocks is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEngineIntegration_Expecter) GetStateLocks(ctx interface{}) *MockEngineIntegration_GetStateLocks_Call {
	return &MockEngineIntegration_GetStateLocks_Call{Call: _e.mock.On("GetStateLocks", ctx)}
}

func (_c *MockEngineIntegration_GetStateLocks_Call) Run(run func(ctx context.Context)) *MockEngineIntegration_GetStateLocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEngineIntegration_GetStateLocks_Call) Return(bytes []byte, err error) *MockEngineIntegration_GetStateLocks_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *MockEngineIntegration_GetStateLocks_Call) RunAndReturn(run func(ctx context.Context) ([]byte, error)) *MockEngineIntegration_GetStateLocks_Call {
	_c.Call.Return(run)
	return _c
}

// ResetTransactions provides a mock function for the type MockEngineIntegration
func (_mock *MockEngineIntegration) ResetTransactions(ctx context.Context, transactionID uuid.UUID) {
	_mock.Called(ctx, transactionID)
	return
}

// MockEngineIntegration_ResetTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetTransactions'
type MockEngineIntegration_ResetTransactions_Call struct {
	*mock.Call
}

// ResetTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - transactionID uuid.UUID
func (_e *MockEngineIntegration_Expecter) ResetTransactions(ctx interface{}, transactionID interface{}) *MockEngineIntegration_ResetTransactions_Call {
	return &MockEngineIntegration_ResetTransactions_Call{Call: _e.mock.On("ResetTransactions", ctx, transactionID)}
}

func (_c *MockEngineIntegration_ResetTransactions_Call) Run(run func(ctx context.Context, transactionID uuid.UUID)) *MockEngineIntegration_ResetTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEngineIntegration_ResetTransactions_Call) Return() *MockEngineIntegration_ResetTransactions_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockEngineIntegration_ResetTransactions_Call) RunAndReturn(run func(ctx context.Context, transactionID uuid.UUID)) *MockEngineIntegration_ResetTransactions_Call {
	_c.Run(run)
	return _c
}

// WriteLockStatesForTransaction provides a mock function for the type MockEngineIntegration
func (_mock *MockEngineIntegration) WriteLockStatesForTransaction(ctx context.Context, txn *components.PrivateTransaction) error {
	ret := _mock.Called(ctx, txn)

	if len(ret) == 0 {
		panic("no return value specified for WriteLockStatesForTransaction")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *components.PrivateTransaction) error); ok {
		r0 = returnFunc(ctx, txn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEngineIntegration_WriteLockStatesForTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteLockStatesForTransaction'
type MockEngineIntegration_WriteLockStatesForTransaction_Call struct {
	*mock.Call
}

// WriteLockStatesForTransaction is a helper method to define mock.On call
//   - ctx context.Context
//   - txn *components.PrivateTransaction
func (_e *MockEngineIntegration_Expecter) WriteLockStatesForTransaction(ctx interface{}, txn interface{}) *MockEngineIntegration_WriteLockStatesForTransaction_Call {
	return &MockEngineIntegration_WriteLockStatesForTransaction_Call{Call: _e.mock.On("WriteLockStatesForTransaction", ctx, txn)}
}

func (_c *MockEngineIntegration_WriteLockStatesForTransaction_Call) Run(run func(ctx context.Context, txn *components.PrivateTransaction)) *MockEngineIntegration_WriteLockStatesForTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *components.PrivateTransaction
		if args[1] != nil {
			arg1 = args[1].(*components.PrivateTransaction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEngineIntegration_WriteLockStatesForTransaction_Call) Return(err error) *MockEngineIntegration_WriteLockStatesForTransaction_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEngineIntegration_WriteLockStatesForTransaction_Call) RunAndReturn(run func(ctx context.Context, txn *components.PrivateTransaction) error) *MockEngineIntegration_WriteLockStatesForTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEvent creates a new instance of MockEvent. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEvent(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEvent {
	mock := &MockEvent{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEvent is an autogenerated mock type for the Event type
type MockEvent struct {
	mock.Mock
}

type MockEvent_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEvent) EXPECT() *MockEvent_Expecter {
	return &MockEvent_Expecter{mock: &_m.Mock}
}

// GetEventTime provides a mock function for the type MockEvent
func (_mock *MockEvent) GetEventTime() time.Time {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetEventTime")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func() time.Time); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// MockEvent_GetEventTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEventTime'
type MockEvent_GetEventTime_Call struct {
	*mock.Call
}

// GetEventTime is a helper method to define mock.On call
func (_e *MockEvent_Expecter) GetEventTime() *MockEvent_GetEventTime_Call {
	return &MockEvent_GetEventTime_Call{Call: _e.mock.On("GetEventTime")}
}

func (_c *MockEvent_GetEventTime_Call) Run(run func()) *MockEvent_GetEventTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockEvent_GetEventTime_Call) Return(time1 time.Time) *MockEvent_GetEventTime_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *MockEvent_GetEventTime_Call) RunAndReturn(run func() time.Time) *MockEvent_GetEventTime_Call {
	_c.Call.Return(run)
	return _c
}

// Type provides a mock function for the type MockEvent
func (_mock *MockEvent) Type() EventType {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Type")
	}

	var r0 EventType
	if returnFunc, ok := ret.Get(0).(func() EventType); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(EventType)
	}
	return r0
}

// MockEvent_Type_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Type'
type MockEvent_Type_Call struct {
	*mock.Call
}

// Type is a helper method to define mock.On call
func (_e *MockEvent_Expecter) Type() *MockEvent_Type_Call {
	return &MockEvent_Type_Call{Call: _e.mock.On("Type")}
}

func (_c *MockEvent_Type_Call) Run(run func()) *MockEvent_Type_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockEvent_Type_Call) Return(eventType EventType) *MockEvent_Type_Call {
	_c.Call.Return(eventType)
	return _c
}

func (_c *MockEvent_Type_Call) RunAndReturn(run func() EventType) *MockEvent_Type_Call {
	_c.Call.Return(run)
	return _c
}

// TypeString provides a mock function for the type MockEvent
func (_mock *MockEvent) TypeString() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for TypeString")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockEvent_TypeString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TypeString'
type MockEvent_TypeString_Call struct {
	*mock.Call
}

// TypeString is a helper method to define mock.On call
func (_e *MockEvent_Expecter) TypeString() *MockEvent_TypeString_Call {
	return &MockEvent_TypeString_Call{Call: _e.mock.On("TypeString")}
}

func (_c *MockEvent_TypeString_Call) Run(run func()) *MockEvent_TypeString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockEvent_TypeString_Call) Return(s string) *MockEvent_TypeString_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockEvent_TypeString_Call) RunAndReturn(run func() string) *MockEvent_TypeString_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStateDistributionBuilder creates a new instance of MockStateDistributionBuilder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStateDistributionBuilder(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStateDistributionBuilder {
	mock := &MockStateDistributionBuilder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStateDistributionBuilder is an autogenerated mock type for the StateDistributionBuilder type
type MockStateDistributionBuilder struct {
	mock.Mock
}

type MockStateDistributionBuilder_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStateDistributionBuilder) EXPECT() *MockStateDistributionBuilder_Expecter {
	return &MockStateDistributionBuilder_Expecter{mock: &_m.Mock}
}

// Build provides a mock function for the type MockStateDistributionBuilder
func (_mock *MockStateDistributionBuilder) Build(ctx context.Context, txn *components.PrivateTransaction) (*components.StateDistributionSet, error) {
	ret := _mock.Called(ctx, txn)

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 *components.StateDistributionSet
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *components.PrivateTransaction) (*components.StateDistributionSet, error)); ok {
		return returnFunc(ctx, txn)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *components.PrivateTransaction) *components.StateDistributionSet); ok {
		r0 = returnFunc(ctx, txn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*components.StateDistributionSet)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *components.PrivateTransaction) error); ok {
		r1 = returnFunc(ctx, txn)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStateDistributionBuilder_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type MockStateDistributionBuilder_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
//   - ctx context.Context
//   - txn *components.PrivateTransaction
func (_e *MockStateDistributionBuilder_Expecter) Build(ctx interface{}, txn interface{}) *MockStateDistributionBuilder_Build_Call {
	return &MockStateDistributionBuilder_Build_Call{Call: _e.mock.On("Build", ctx, txn)}
}

func (_c *MockStateDistributionBuilder_Build_Call) Run(run func(ctx context.Context, txn *components.PrivateTransaction)) *MockStateDistributionBuilder_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *components.PrivateTransaction
		if args[1] != nil {
			arg1 = args[1].(*components.PrivateTransaction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStateDistributionBuilder_Build_Call) Return(sds *components.StateDistributionSet, err error) *MockStateDistributionBuilder_Build_Call {
	_c.Call.Return(sds, err)
	return _c
}

func (_c *MockStateDistributionBuilder_Build_Call) RunAndReturn(run func(ctx context.Context, txn *components.PrivateTransaction) (*components.StateDistributionSet, error)) *MockStateDistributionBuilder_Build_Call {
	_c.Call.Return(run)
	return _c
}
